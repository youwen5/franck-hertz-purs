/* Generated by Spago v0.93.43 */

// output/Data.Array/foreign.js
var rangeImpl = function(start, end) {
  var step2 = start > end ? -1 : 1;
  var result = new Array(step2 * (end - start) + 1);
  var i = start, n = 0;
  while (i !== end) {
    result[n++] = i;
    i += step2;
  }
  result[n] = i;
  return result;
};
var replicateFill = function(count, value) {
  if (count < 1) {
    return [];
  }
  var result = new Array(count);
  return result.fill(value);
};
var replicatePolyfill = function(count, value) {
  var result = [];
  var n = 0;
  for (var i = 0; i < count; i++) {
    result[n++] = value;
  }
  return result;
};
var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
var length = function(xs) {
  return xs.length;
};
var unconsImpl = function(empty2, next, xs) {
  return xs.length === 0 ? empty2({}) : next(xs[0])(xs.slice(1));
};
var indexImpl = function(just, nothing, xs, i) {
  return i < 0 || i >= xs.length ? nothing : just(xs[i]);
};
var filterImpl = function(f, xs) {
  return xs.filter(f);
};
var sliceImpl = function(s, e, l) {
  return l.slice(s, e);
};
var zipWithImpl = function(f, xs, ys) {
  var l = xs.length < ys.length ? xs.length : ys.length;
  var result = new Array(l);
  for (var i = 0; i < l; i++) {
    result[i] = f(xs[i])(ys[i]);
  }
  return result;
};

// output/Data.Functor/foreign.js
var arrayMap = function(f) {
  return function(arr) {
    var l = arr.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(arr[i]);
    }
    return result;
  };
};

// output/Control.Semigroupoid/index.js
var semigroupoidFn = {
  compose: function(f) {
    return function(g) {
      return function(x) {
        return f(g(x));
      };
    };
  }
};

// output/Control.Category/index.js
var identity = function(dict) {
  return dict.identity;
};
var categoryFn = {
  identity: function(x) {
    return x;
  },
  Semigroupoid0: function() {
    return semigroupoidFn;
  }
};

// output/Data.Boolean/index.js
var otherwise = true;

// output/Data.Function/index.js
var $$const = function(a) {
  return function(v) {
    return a;
  };
};

// output/Data.Functor/index.js
var map = function(dict) {
  return dict.map;
};
var functorArray = {
  map: arrayMap
};

// output/Data.Semigroup/foreign.js
var concatArray = function(xs) {
  return function(ys) {
    if (xs.length === 0) return ys;
    if (ys.length === 0) return xs;
    return xs.concat(ys);
  };
};

// output/Data.Semigroup/index.js
var semigroupArray = {
  append: concatArray
};
var append = function(dict) {
  return dict.append;
};

// output/Control.Bind/foreign.js
var arrayBind = typeof Array.prototype.flatMap === "function" ? function(arr) {
  return function(f) {
    return arr.flatMap(f);
  };
} : function(arr) {
  return function(f) {
    var result = [];
    var l = arr.length;
    for (var i = 0; i < l; i++) {
      var xs = f(arr[i]);
      var k = xs.length;
      for (var j = 0; j < k; j++) {
        result.push(xs[j]);
      }
    }
    return result;
  };
};

// output/Data.Bounded/foreign.js
var topInt = 2147483647;
var bottomInt = -2147483648;
var topChar = String.fromCharCode(65535);
var bottomChar = String.fromCharCode(0);
var topNumber = Number.POSITIVE_INFINITY;
var bottomNumber = Number.NEGATIVE_INFINITY;

// output/Data.Ord/foreign.js
var unsafeCompareImpl = function(lt) {
  return function(eq2) {
    return function(gt) {
      return function(x) {
        return function(y) {
          return x < y ? lt : x === y ? eq2 : gt;
        };
      };
    };
  };
};
var ordIntImpl = unsafeCompareImpl;
var ordNumberImpl = unsafeCompareImpl;

// output/Data.Eq/foreign.js
var refEq = function(r1) {
  return function(r2) {
    return r1 === r2;
  };
};
var eqIntImpl = refEq;
var eqNumberImpl = refEq;

// output/Data.Eq/index.js
var eqNumber = {
  eq: eqNumberImpl
};
var eqInt = {
  eq: eqIntImpl
};

// output/Data.Ordering/index.js
var LT = /* @__PURE__ */ function() {
  function LT2() {
  }
  ;
  LT2.value = new LT2();
  return LT2;
}();
var GT = /* @__PURE__ */ function() {
  function GT2() {
  }
  ;
  GT2.value = new GT2();
  return GT2;
}();
var EQ = /* @__PURE__ */ function() {
  function EQ2() {
  }
  ;
  EQ2.value = new EQ2();
  return EQ2;
}();

// output/Data.Ring/foreign.js
var intSub = function(x) {
  return function(y) {
    return x - y | 0;
  };
};

// output/Data.Semiring/foreign.js
var intAdd = function(x) {
  return function(y) {
    return x + y | 0;
  };
};
var intMul = function(x) {
  return function(y) {
    return x * y | 0;
  };
};
var numAdd = function(n1) {
  return function(n2) {
    return n1 + n2;
  };
};
var numMul = function(n1) {
  return function(n2) {
    return n1 * n2;
  };
};

// output/Data.Semiring/index.js
var zero = function(dict) {
  return dict.zero;
};
var semiringNumber = {
  add: numAdd,
  zero: 0,
  mul: numMul,
  one: 1
};
var semiringInt = {
  add: intAdd,
  zero: 0,
  mul: intMul,
  one: 1
};
var add = function(dict) {
  return dict.add;
};

// output/Data.Ring/index.js
var ringInt = {
  sub: intSub,
  Semiring0: function() {
    return semiringInt;
  }
};

// output/Data.Ord/index.js
var ordNumber = /* @__PURE__ */ function() {
  return {
    compare: ordNumberImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqNumber;
    }
  };
}();
var ordInt = /* @__PURE__ */ function() {
  return {
    compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqInt;
    }
  };
}();
var compare = function(dict) {
  return dict.compare;
};
var min = function(dictOrd) {
  var compare3 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare3(x)(y);
      if (v instanceof LT) {
        return x;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return y;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): " + [v.constructor.name]);
    };
  };
};

// output/Data.Bounded/index.js
var top = function(dict) {
  return dict.top;
};
var boundedInt = {
  top: topInt,
  bottom: bottomInt,
  Ord0: function() {
    return ordInt;
  }
};
var bottom = function(dict) {
  return dict.bottom;
};

// output/Data.Maybe/index.js
var identity2 = /* @__PURE__ */ identity(categoryFn);
var Nothing = /* @__PURE__ */ function() {
  function Nothing2() {
  }
  ;
  Nothing2.value = new Nothing2();
  return Nothing2;
}();
var Just = /* @__PURE__ */ function() {
  function Just2(value0) {
    this.value0 = value0;
  }
  ;
  Just2.create = function(value0) {
    return new Just2(value0);
  };
  return Just2;
}();
var maybe = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v;
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var fromMaybe = function(a) {
  return maybe(a)(identity2);
};

// output/Data.EuclideanRing/foreign.js
var intDegree = function(x) {
  return Math.min(Math.abs(x), 2147483647);
};
var intDiv = function(x) {
  return function(y) {
    if (y === 0) return 0;
    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
  };
};
var intMod = function(x) {
  return function(y) {
    if (y === 0) return 0;
    var yy = Math.abs(y);
    return (x % yy + yy) % yy;
  };
};

// output/Data.CommutativeRing/index.js
var commutativeRingInt = {
  Ring0: function() {
    return ringInt;
  }
};

// output/Data.EuclideanRing/index.js
var mod = function(dict) {
  return dict.mod;
};
var euclideanRingInt = {
  degree: intDegree,
  div: intDiv,
  mod: intMod,
  CommutativeRing0: function() {
    return commutativeRingInt;
  }
};

// output/Data.Monoid/index.js
var mempty = function(dict) {
  return dict.mempty;
};

// output/Data.Foldable/foreign.js
var foldrArray = function(f) {
  return function(init) {
    return function(xs) {
      var acc = init;
      var len = xs.length;
      for (var i = len - 1; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };
};
var foldlArray = function(f) {
  return function(init) {
    return function(xs) {
      var acc = init;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
};

// output/Data.Tuple/index.js
var Tuple = /* @__PURE__ */ function() {
  function Tuple2(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
  }
  ;
  Tuple2.create = function(value0) {
    return function(value1) {
      return new Tuple2(value0, value1);
    };
  };
  return Tuple2;
}();

// output/Data.Foldable/index.js
var foldr = function(dict) {
  return dict.foldr;
};
var foldl = function(dict) {
  return dict.foldl;
};
var sum = function(dictFoldable) {
  var foldl2 = foldl(dictFoldable);
  return function(dictSemiring) {
    return foldl2(add(dictSemiring))(zero(dictSemiring));
  };
};
var foldMapDefaultR = function(dictFoldable) {
  var foldr2 = foldr(dictFoldable);
  return function(dictMonoid) {
    var append3 = append(dictMonoid.Semigroup0());
    var mempty2 = mempty(dictMonoid);
    return function(f) {
      return foldr2(function(x) {
        return function(acc) {
          return append3(f(x))(acc);
        };
      })(mempty2);
    };
  };
};
var foldableArray = {
  foldr: foldrArray,
  foldl: foldlArray,
  foldMap: function(dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
  }
};

// output/Data.Function.Uncurried/foreign.js
var runFn2 = function(fn) {
  return function(a) {
    return function(b) {
      return fn(a, b);
    };
  };
};
var runFn3 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return fn(a, b, c);
      };
    };
  };
};
var runFn4 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function(d) {
          return fn(a, b, c, d);
        };
      };
    };
  };
};

// output/Data.Array/index.js
var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);
var zip = /* @__PURE__ */ function() {
  return zipWith(Tuple.create);
}();
var uncons = /* @__PURE__ */ function() {
  return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {
    return function(xs) {
      return new Just({
        head: x,
        tail: xs
      });
    };
  });
}();
var slice = /* @__PURE__ */ runFn3(sliceImpl);
var take = function(n) {
  return function(xs) {
    var $152 = n < 1;
    if ($152) {
      return [];
    }
    ;
    return slice(0)(n)(xs);
  };
};
var range2 = /* @__PURE__ */ runFn2(rangeImpl);
var index = /* @__PURE__ */ function() {
  return runFn4(indexImpl)(Just.create)(Nothing.value);
}();
var filter = /* @__PURE__ */ runFn2(filterImpl);
var drop = function(n) {
  return function(xs) {
    var $173 = n < 1;
    if ($173) {
      return xs;
    }
    ;
    return slice(n)(length(xs))(xs);
  };
};

// output/Data.Int/foreign.js
var fromNumberImpl = function(just) {
  return function(nothing) {
    return function(n) {
      return (n | 0) === n ? just(n) : nothing;
    };
  };
};
var toNumber = function(n) {
  return n;
};

// output/Data.Number/foreign.js
var isFiniteImpl = isFinite;
var round = Math.round;

// output/Data.Int/index.js
var top2 = /* @__PURE__ */ top(boundedInt);
var bottom2 = /* @__PURE__ */ bottom(boundedInt);
var fromNumber = /* @__PURE__ */ function() {
  return fromNumberImpl(Just.create)(Nothing.value);
}();
var unsafeClamp = function(x) {
  if (!isFiniteImpl(x)) {
    return 0;
  }
  ;
  if (x >= toNumber(top2)) {
    return top2;
  }
  ;
  if (x <= toNumber(bottom2)) {
    return bottom2;
  }
  ;
  if (otherwise) {
    return fromMaybe(0)(fromNumber(x));
  }
  ;
  throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x.constructor.name]);
};
var round2 = function($37) {
  return unsafeClamp(round($37));
};

// output/Random/index.js
var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
var randomDouble = function(state) {
  var newSeed = mod2((1664525 * state.seed | 0) + 1013904223 | 0)(2147483647);
  var value = toNumber(newSeed) / toNumber(2147483647);
  return {
    value,
    newState: {
      seed: newSeed
    }
  };
};
var randomBool = function(probability) {
  return function(state) {
    var v = randomDouble(state);
    return {
      value: v.value < probability,
      newState: v.newState
    };
  };
};
var mkRandomState = function(seed) {
  return {
    seed
  };
};

// output/Model/index.js
var mercuryExcitationEnergy = 4.9;
var maxElectrons = 1e3;

// output/Physics/index.js
var min3 = /* @__PURE__ */ min(ordInt);
var append2 = /* @__PURE__ */ append(semigroupArray);
var min1 = /* @__PURE__ */ min(ordNumber);
var map2 = /* @__PURE__ */ map(functorArray);
var mod3 = /* @__PURE__ */ mod(euclideanRingInt);
var emission = function(timeStep) {
  return function(filamentVoltage) {
    return function(randomState) {
      var baseEmissionRate = filamentVoltage * 0.5;
      var v = randomDouble(randomState);
      var makeElectron = function(v1) {
        return function(state) {
          var v2 = randomDouble(state);
          return {
            electron: {
              energy: v2.value * 0.1,
              emittedAt: timeStep,
              position: 0
            },
            newState: v2.newState
          };
        };
      };
      var emissionRate = baseEmissionRate * (0.8 + v.value * 0.4);
      var numEmissions = min3(round2(emissionRate))(maxElectrons);
      var createElectrons = function(v1) {
        return function(v2) {
          if (v1 === 0) {
            return {
              electrons: [],
              newState: v2
            };
          }
          ;
          var v3 = makeElectron(v1)(v2);
          var v4 = createElectrons(v1 - 1 | 0)(v3.newState);
          return {
            electrons: append2([v3.electron])(v4.electrons),
            newState: v4.newState
          };
        };
      };
      return createElectrons(numEmissions)(v.newState);
    };
  };
};
var collide = function(mercuryDensity) {
  return function(randomState) {
    return function(electron) {
      var collisionProbability = mercuryDensity * 0.01 * function() {
        var $45 = electron.energy > mercuryExcitationEnergy;
        if ($45) {
          return 0.8;
        }
        ;
        return 0.2;
      }();
      var v = randomBool(collisionProbability)(randomState);
      var $47 = v.value && electron.energy >= mercuryExcitationEnergy;
      if ($47) {
        return {
          electron: {
            emittedAt: electron.emittedAt,
            position: electron.position,
            energy: electron.energy - mercuryExcitationEnergy
          },
          newState: v.newState
        };
      }
      ;
      return {
        electron,
        newState: v.newState
      };
    };
  };
};
var processCollisions = function(electrons) {
  return function(mercuryDensity) {
    return function(randomState) {
      var go = function(processed) {
        return function(remaining) {
          return function(state) {
            var v = uncons(remaining);
            if (v instanceof Nothing) {
              return {
                electrons: processed,
                newState: state
              };
            }
            ;
            if (v instanceof Just) {
              var v1 = collide(mercuryDensity)(state)(v.value0.head);
              var v2 = go(processed)(v.value0.tail)(v1.newState);
              return {
                electrons: append2([v1.electron])(v2.electrons),
                newState: v2.newState
              };
            }
            ;
            throw new Error("Failed pattern match at Physics (line 91, column 7 - line 98, column 83): " + [v.constructor.name]);
          };
        };
      };
      return go([])(electrons)(randomState);
    };
  };
};
var collected = function(retardingVoltage) {
  return function(electron) {
    return electron.position >= 0.95 && electron.energy >= retardingVoltage;
  };
};
var accelerate = function(acceleratingVoltage) {
  return function(electron) {
    var newPosition = min1(1)(electron.position + 0.02);
    var energyGain = acceleratingVoltage * 0.01;
    return {
      emittedAt: electron.emittedAt,
      energy: electron.energy + energyGain,
      position: newPosition
    };
  };
};
var step = function(state) {
  return function(randomState) {
    var v = emission(state.timeStep)(state.settings.filamentVoltage)(randomState);
    var combinedElectrons = take(maxElectrons)(append2(state.electrons)(v.electrons));
    var acceleratedElectrons = map2(accelerate(state.settings.acceleratingVoltage))(combinedElectrons);
    var v1 = processCollisions(acceleratedElectrons)(state.mercuryDensity)(v.newState);
    var remainingElectrons = filter(function(e) {
      return !collected(state.settings.retardingVoltage)(e);
    })(v1.electrons);
    var newVoltageSteps = function() {
      var $62 = mod3(state.timeStep)(10) === 0;
      if ($62) {
        return append2(state.voltageSteps)([state.settings.acceleratingVoltage]);
      }
      ;
      return state.voltageSteps;
    }();
    var collectedElectrons = filter(collected(state.settings.retardingVoltage))(v1.electrons);
    var currentReading = toNumber(length(collectedElectrons)) * 0.01;
    var newReadings = function() {
      var $63 = mod3(state.timeStep)(10) === 0;
      if ($63) {
        return append2(state.readings)([currentReading]);
      }
      ;
      return state.readings;
    }();
    var newCollectedCount = state.collectedCount + length(collectedElectrons) | 0;
    return {
      newState: {
        settings: state.settings,
        mercuryDensity: state.mercuryDensity,
        electrons: remainingElectrons,
        collectedCount: newCollectedCount,
        timeStep: state.timeStep + 1 | 0,
        currentReading,
        readings: newReadings,
        voltageSteps: newVoltageSteps
      },
      randomState: v1.newState
    };
  };
};

// output/Simulation/index.js
var map3 = /* @__PURE__ */ map(functorArray);
var simulateVoltageSweep = function(initialState2) {
  return function(initialRandomState) {
    return function(startVoltage) {
      return function(endVoltage) {
        return function(stepSize) {
          return function(stepsPerVoltage) {
            var totalSteps = round2((endVoltage - startVoltage) / stepSize);
            var voltageSteps = map3(function(i) {
              return startVoltage + stepSize * toNumber(i);
            })(range2(0)(totalSteps));
            var simulateSteps = function($copy_v) {
              return function($copy_v1) {
                return function($copy_v2) {
                  var $tco_var_v = $copy_v;
                  var $tco_var_v1 = $copy_v1;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(v, v1, v2) {
                    if (v2 === 0) {
                      $tco_done = true;
                      return {
                        state: v,
                        randomState: v1
                      };
                    }
                    ;
                    var v3 = step(v)(v1);
                    $tco_var_v = v3.newState;
                    $tco_var_v1 = v3.randomState;
                    $copy_v2 = v2 - 1 | 0;
                    return;
                  }
                  ;
                  while (!$tco_done) {
                    $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
                  }
                  ;
                  return $tco_result;
                };
              };
            };
            var simulateVoltage = function(state) {
              return function(randomState) {
                return function(voltage) {
                  var stateWithVoltage = {
                    collectedCount: state.collectedCount,
                    currentReading: state.currentReading,
                    electrons: state.electrons,
                    mercuryDensity: state.mercuryDensity,
                    readings: state.readings,
                    timeStep: state.timeStep,
                    voltageSteps: state.voltageSteps,
                    settings: {
                      filamentVoltage: state.settings.filamentVoltage,
                      retardingVoltage: state.settings.retardingVoltage,
                      acceleratingVoltage: voltage
                    }
                  };
                  return simulateSteps(stateWithVoltage)(randomState)(stepsPerVoltage);
                };
              };
            };
            var runSweep = function($copy_state) {
              return function($copy_randomState) {
                return function($copy_voltages) {
                  var $tco_var_state = $copy_state;
                  var $tco_var_randomState = $copy_randomState;
                  var $tco_done1 = false;
                  var $tco_result;
                  function $tco_loop(state, randomState, voltages) {
                    var v = uncons(voltages);
                    if (v instanceof Nothing) {
                      $tco_done1 = true;
                      return {
                        state,
                        randomState
                      };
                    }
                    ;
                    if (v instanceof Just) {
                      var result1 = simulateVoltage(state)(randomState)(v.value0.head);
                      $tco_var_state = result1.state;
                      $tco_var_randomState = result1.randomState;
                      $copy_voltages = v.value0.tail;
                      return;
                    }
                    ;
                    throw new Error("Failed pattern match at Simulation (line 38, column 43 - line 44, column 54): " + [v.constructor.name]);
                  }
                  ;
                  while (!$tco_done1) {
                    $tco_result = $tco_loop($tco_var_state, $tco_var_randomState, $copy_voltages);
                  }
                  ;
                  return $tco_result;
                };
              };
            };
            var result = runSweep(initialState2)(initialRandomState)(voltageSteps);
            return {
              finalState: result.state,
              finalRandomState: result.randomState
            };
          };
        };
      };
    };
  };
};

// output/Main/index.js
var map4 = /* @__PURE__ */ map(functorArray);
var sum2 = /* @__PURE__ */ sum(foldableArray)(semiringNumber);
var initialState = function(settings) {
  return {
    electrons: [],
    collectedCount: 0,
    settings,
    mercuryDensity: 1,
    timeStep: 0,
    currentReading: 0,
    readings: [],
    voltageSteps: []
  };
};
var runFranckHertzExperiment = function(filamentVoltage) {
  return function(initialAcceleratingVoltage) {
    return function(finalAcceleratingVoltage) {
      return function(voltageStep) {
        return function(retardingVoltage) {
          return function(mercuryDensity) {
            return function(randomSeed) {
              var settings = {
                filamentVoltage,
                acceleratingVoltage: initialAcceleratingVoltage,
                retardingVoltage
              };
              var state0 = function() {
                var v = initialState(settings);
                return {
                  collectedCount: v.collectedCount,
                  currentReading: v.currentReading,
                  electrons: v.electrons,
                  readings: v.readings,
                  settings: v.settings,
                  timeStep: v.timeStep,
                  voltageSteps: v.voltageSteps,
                  mercuryDensity
                };
              }();
              var randomState = mkRandomState(randomSeed);
              var result = simulateVoltageSweep(state0)(randomState)(initialAcceleratingVoltage)(finalAcceleratingVoltage)(voltageStep)(500);
              var findPeaks = function(voltages) {
                return function(currents) {
                  var isPeak = function(i) {
                    var prev = fromMaybe(0)(index(currents)(i - 1 | 0));
                    var next = fromMaybe(0)(index(currents)(i + 1 | 0));
                    var curr = fromMaybe(0)(index(currents)(i));
                    return curr > prev && curr > next;
                  };
                  var indicesToCheck = range2(1)(length(currents) - 2 | 0);
                  var peakIndices = filter(isPeak)(indicesToCheck);
                  return map4(function(i) {
                    return fromMaybe(0)(index(voltages)(i));
                  })(peakIndices);
                };
              };
              var findDips = function(voltages) {
                return function(currents) {
                  var isDip = function(i) {
                    var prev = fromMaybe(0)(index(currents)(i - 1 | 0));
                    var next = fromMaybe(0)(index(currents)(i + 1 | 0));
                    var curr = fromMaybe(0)(index(currents)(i));
                    return curr < prev && curr < next;
                  };
                  var indicesToCheck = range2(1)(length(currents) - 2 | 0);
                  var dipIndices = filter(isDip)(indicesToCheck);
                  return map4(function(i) {
                    return fromMaybe(0)(index(voltages)(i));
                  })(dipIndices);
                };
              };
              var peakVoltages = findPeaks(result.finalState.voltageSteps)(result.finalState.readings);
              var dipVoltages = findDips(result.finalState.voltageSteps)(result.finalState.readings);
              var calculateAverageSpacing = function(voltages) {
                var v = length(voltages);
                if (v === 0) {
                  return 0;
                }
                ;
                if (v === 1) {
                  return 0;
                }
                ;
                var pairs = zip(voltages)(drop(1)(voltages));
                var differences = map4(function(v1) {
                  return v1.value1 - v1.value0;
                })(pairs);
                var total = sum2(differences);
                return total / toNumber(length(differences));
              };
              var averageSpacing = calculateAverageSpacing(peakVoltages);
              return {
                voltages: result.finalState.voltageSteps,
                currents: result.finalState.readings,
                peakVoltages,
                dipVoltages,
                averageSpacing,
                totalElectrons: result.finalState.collectedCount,
                timeSteps: result.finalState.timeStep
              };
            };
          };
        };
      };
    };
  };
};
export {
  initialState,
  runFranckHertzExperiment
};
